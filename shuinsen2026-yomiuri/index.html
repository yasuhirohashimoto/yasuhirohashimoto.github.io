<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>衆院選2026 候補者：政策志向マップ</title>

  <!-- =========================
       スタイル
       ========================= -->
  <style>
    /* -------------------------
       1) デザイントークン
       ------------------------- */
    :root {
      --bg-glass: rgba(255, 255, 255, 0.9);
      --bg-glass-dark: rgba(0, 0, 0, 0.8);
      --primary-color: #1f77b4;
      --border-color: rgba(0, 0, 0, 0.1);
      --text-main: #333;
      --text-sub: #666;
      --accent-blue: #4fc3f7;

      --radius-lg: 16px;
      --radius-md: 8px;
      --radius-sm: 4px;

      --shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);

      --z-ui: 1000;
      --z-modal: 2000;
      --z-tooltip: 3000;
    }

    /* -------------------------
       2) 基本設定
       ------------------------- */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: "Noto Sans JP", "Meiryo", sans-serif;
      background-color: #f8f9fa;
      color: var(--text-main);
    }

    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    /* -------------------------
       3) 共通UIブロック
       ------------------------- */
    #legend-panel,
    #filter-panel {
      position: absolute;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      z-index: var(--z-ui);
    }

    .legend-header,
    .filter-header {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      font-weight: bold;
      border-bottom: 2px solid var(--border-color);
      gap: 10px;
    }

    .legend-title,
    .filter-title {
      font-weight: bold;
      font-size: 16px;
      margin: 0;
      padding: 0;
      border: none;
      flex: 1 1 auto;
      min-width: 0;
    }

    /* -------------------------
       4) 検索UI
       ------------------------- */
    #search-container {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: var(--z-ui);
      width: 320px;
    }

    #search-input {
      width: 100%;
      padding: 12px 20px;
      border-radius: 30px;
      border: 1px solid var(--border-color);
      background: var(--bg-glass);
      backdrop-filter: blur(8px);
      font-size: 16px;
      box-shadow: var(--shadow);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    #search-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(31, 119, 180, 0.2);
    }

    #search-results {
      list-style: none;
      margin: 8px 0 0 0;
      padding: 8px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow);
      max-height: 300px;
      overflow-y: auto;
      display: none;
      border: 1px solid var(--border-color);
    }

    .search-item {
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition);
    }

    .search-item:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .search-party {
      font-size: 11px;
      color: var(--text-sub);
      background: rgba(0, 0, 0, 0.08);
      padding: 2px 8px;
      border-radius: 12px;
    }

    .ui-pill {
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid var(--border-color);
      border-radius: 999px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
    }

    /* -------------------------
       5) 凡例UI
       ------------------------- */

    #legend-panel {
      bottom: 30px;
      right: 30px;
      padding: 16px;
      min-width: 220px;
      max-height: 400px;
      overflow-y: auto;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      cursor: pointer;
      padding: 6px 10px;
      transition: var(--transition);
      border-left: 4px solid transparent;
      border-radius: var(--radius-sm);
      -webkit-tap-highlight-color: transparent;
    }

    .legend-item:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .legend-item.selected {
      background-color: rgba(0, 0, 0, 0.08);
      border-left: 4px solid var(--primary-color);
      font-weight: bold;
    }

    .legend-icon {
      width: 18px;
      height: 18px;
      margin-right: 12px;
      border-radius: 2px;
    }

    /* --- 凡例内の当選トグル --- */
    .elected-legend-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;

      padding: 6px 8px;

      color: var(--text-sub);
      font-size: 12px;
    }

    .elected-legend-toggle input {
      position: absolute;
      opacity: 0;
      width: 1px;
      height: 1px;
    }

    .elected-legend-switch {
      width: 34px;
      height: 20px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.15);
      position: relative;
      transition: var(--transition);
      flex: 0 0 auto;
    }

    .elected-legend-switch::before {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: var(--transition);
    }

    .elected-legend-toggle input:checked+.elected-legend-switch {
      background: rgba(220, 0, 0, 0.65);
    }

    .elected-legend-toggle input:checked+.elected-legend-switch::before {
      transform: translateX(14px);
    }

    /* -------------------------
       6) 説明ボタンとモーダル
       ------------------------- */
    #about-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      background: var(--bg-glass);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      font-weight: bold;
      cursor: pointer;
      z-index: var(--z-ui);
      font-size: 20px;
      color: var(--text-sub);
      box-shadow: var(--shadow);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: var(--transition);
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }

    @media (hover: hover) {
      #about-btn:hover {
        background: var(--primary-color);
        color: white;
        transform: scale(1.05);
      }
    }

    #about-btn:active {
      transform: scale(0.95);
    }

    #about-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      z-index: var(--z-modal);
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    #about-content {
      color: var(--text-main);
      background: white;
      padding: 40px;
      border-radius: var(--radius-lg);
      max-width: 640px;
      width: 100%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      position: relative;
      line-height: 1.8;
    }

    #about-content h2 {
      margin: 0 0 24px 0;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border-color);
      font-size: 24px;
      text-align: center;
    }

    #about-content h3 {
      font-size: 18px;
      margin-top: 32px;
      margin-bottom: 12px;
    }

    #close-modal {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 28px;
      cursor: pointer;
      color: #bbb;
      transition: var(--transition);
      -webkit-tap-highlight-color: transparent;
    }

    #close-modal:hover {
      color: var(--text-main);
      transform: rotate(90deg);
    }

    /* -------------------------
       7) ツールチップ
       ------------------------- */
    #tooltip {
      position: absolute;
      display: none;
      background: var(--bg-glass-dark);
      backdrop-filter: blur(8px);
      color: #fff;
      padding: 14px;
      border-radius: var(--radius-md);
      font-size: 13px;
      z-index: var(--z-tooltip);
      line-height: 1.6;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.1);
      pointer-events: none;
      /* PCでは無効。モバイルはメディアクエリで有効化 */
      min-width: 200px;
    }

    #tooltip strong {
      font-size: 16px;
      display: block;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 4px;
    }

    .tooltip-party {
      font-size: 12px;
      margin-bottom: 5px;
      color: #ddd;
    }

    /* 既存仕様に合わせ「回答一覧全体」を強調表示するスタイルを維持 */
    .tooltip-answers {
      font-family: "Roboto Mono", monospace;
      color: var(--accent-blue);
      font-weight: bold;
      font-size: 12px;
      line-height: 1.6;
      word-break: break-word;
    }

    /* -------------------------
       8) 政策フィルターパネル
       ------------------------- */
    #filter-panel {
      bottom: 30px;
      left: 30px;
      width: 300px;
      padding: 16px;
      transition: var(--transition);
    }

    .filter-reset-btn {
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text-sub);
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      -webkit-tap-highlight-color: transparent;
    }

    .filter-reset-btn:hover {
      background: #eee;
      color: #333;
    }

    .filter-reset-btn:active {
      transform: scale(0.98);
    }

    #issue-select {
      width: 100%;
      padding: 8px;
      border-radius: var(--radius-sm);
      border: 1px solid #ccc;
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      margin-bottom: 16px;
      outline: none;
    }

    .filter-control.is-disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-sub);
      margin-bottom: 4px;
    }

    .range-labels span {
      max-width: 45%;
    }

    #value-range {
      width: 100%;
      margin: 8px 0;
      cursor: pointer;
    }

    /* -------------------------
       9) モバイル
       ------------------------- */
    @media (max-width: 600px) {

      /* レイアウト調整 */
      #search-container {
        width: calc(100% - 80px);
        top: 15px;
        left: 15px;
      }

      #about-btn {
        top: 15px;
        right: 15px;
        width: 40px;
        height: 40px;
      }

      #about-content {
        padding: 30px 20px;
        width: 95%;
        font-size: 14px;
      }

      #legend-panel {
        left: 15px;
        width: calc(100% - 30px);
        bottom: 15px;
        max-height: 200px;
        padding: 12px;
      }

      /* フォールバック: JS実行前の初期位置（JSで上書き） */
      #filter-panel {
        left: 15px;
        width: calc(100% - 30px);
        bottom: 90px;
      }

      /* モバイルではツールチップをタップ可能 */
      #tooltip {
        pointer-events: auto;
        cursor: pointer;
      }

      /* ---------- モバイル: ヘッダーをタップして開閉 ---------- */
      #legend-panel .legend-header,
      #filter-panel .filter-header {
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      /* パネルタイトルの開閉アイコン */
      #legend-panel .legend-title,
      #filter-panel .filter-title {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
    
      #legend-panel .legend-title::after,
      #filter-panel .filter-title::after {
        content: "▾";
        position: static;
        transform: none;
        color: var(--text-sub);
        font-weight: bold;
      }
    
      #legend-panel.minimized .legend-title::after,
      #filter-panel.minimized .filter-title::after {
        content: "▸";
      }

      /* 最小化: 凡例 */
      #legend-panel.minimized {
        /* 最大高さ指定を残す場合はここで有効化 */
        overflow: hidden;
        padding: 12px;
      }

      #legend-panel.minimized .legend-item {
        display: none;
      }

      #legend-panel.minimized .legend-header {
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
      }

      /* 最小化: フィルター */
      #filter-panel.minimized {
        padding: 12px;
      }

      #filter-panel.minimized .filter-row,
      #filter-panel.minimized .filter-control {
        display: none;
      }

      #filter-panel.minimized .filter-header {
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
      }
    }
  </style>

  <!-- =========================
       ライブラリ
       ========================= -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
  <!-- 検索 -->
  <div id="search-container">
    <input type="text" id="search-input" placeholder="候補者名・政党名で検索" />
    <ul id="search-results"></ul>
  </div>

  <!-- ツールチップ -->
  <div id="tooltip"></div>

  <!-- 説明 -->
  <button id="about-btn" title="このサイトについて" aria-label="このサイトについて">?</button>

  <div id="about-modal">
    <div id="about-content">
      <span id="close-modal" aria-label="閉じる">&times;</span>

      <h2>このマップについて</h2>
      <p>
        この3Dマップは、衆議院選挙（2026年）における各候補者の政策志向についてのアンケートデータを分析し、回答傾向が似ている候補者同士が近くになるように配置したものです。
      </p>

      <h3>データ出典</h3>
      <p>
        <a href="https://www.yomiuri.co.jp/election/shugiin/2026candidates/" target="_blank" rel="noopener noreferrer">
          読売新聞オンライン「衆院選2026　立候補者一覧」
        </a>
      </p>

      <h3>使用データと集計方法</h3>
      <ul>
        <li><strong>対象設問（Q2～Q23）:</strong></li>
        <li>
          <strong>データ処理:</strong><br />
          各種政策に対する志向を問う数値データ（Q2〜Q23）のみを抽出し、各質問に対する回答を標準化しています。「回答なし」は、全回答者の平均値に置き換えています。<br />
          ※ 完全に同一な値を持つ候補者の位置をずらして見やすくするために、元ベクトルの各成分に平均0、標準偏差0.05のガウシアンノイズを加えています。
        </li>
      </ul>

      <h3>分析手法：主成分分析 (PCA)</h3>
      <p>27次元（質問数）の回答データを、情報の損失をなるべく抑えつつ3次元空間に圧縮しました。</p>
      <ul>
        <li><strong>第1主成分 (PC1):</strong> 寄与率 <strong>35.4%</strong></li>
        <li><strong>第2主成分 (PC2):</strong> 寄与率 <strong>17.0%</strong></li>
        <li><strong>第3主成分 (PC3):</strong> 寄与率 <strong>6.6%</strong></li>
        <li><strong>累積寄与率:</strong> <strong>59.0%</strong>（データの約59%の情報がこの図で説明されています）</li>
      </ul>

      <h3>操作方法</h3>
      <ul>
        <li><strong>回転：</strong> 指一本でドラッグ (PC：左ドラッグ)</li>
        <li><strong>ズーム：</strong> 二本指でピンチ (PC：ホイール)</li>
        <li><strong>移動：</strong> 二本指でスワイプ (PC：右ドラッグ)</li>
        <li><strong>詳細：</strong> 点をタップ (PC：ホバー)</li>
      </ul>
    </div>
  </div>

  <!-- 凡例 -->
  <div id="legend-panel">
    <div class="legend-header">
      <span class="legend-title">政党一覧</span>
      <label class="elected-legend-toggle ui-pill" title="当選を表示">
        <span class="elected-legend-label">当選</span>
        <input type="checkbox" id="elected-toggle" />
        <span class="elected-legend-switch" aria-hidden="true"></span>
      </label>
    </div>
  </div>

  <!-- 政策フィルター -->
  <div id="filter-panel">
    <div class="filter-header">
      <span class="filter-title">政策で絞り込み</span>
      <button id="filter-reset" class="filter-reset-btn ui-pill" type="button" aria-label="政策フィルターをリセット">
        ↺ リセット
      </button>
    </div>

    <div class="filter-row">
      <select id="issue-select">
        <option value="">質問項目を選択...</option>
      </select>
    </div>

    <!-- 初期状態は無効（スタイル用クラスで管理） -->
    <div class="filter-control is-disabled" id="filter-control">
      <div class="range-labels">
        <span id="label-low">---</span>
        <span id="label-high">---</span>
      </div>
      <input type="range" id="value-range" min="1" max="5" step="1" value="3" list="value-range-options"/>
      <datalist id="value-range-options"></datalist>
    </div>
  </div>

  <!-- =========================
       スクリプト
       ========================= -->
  <script>
    async function loadData() {
      try {
        const [candidatesRes, partiesRes, electedRes] = await Promise.all([
          fetch('./data/candidates.json'),
          fetch('./data/parties.json'),
          fetch('./data/elected.json')
        ]);
        if (!candidatesRes.ok || !partiesRes.ok || !electedRes.ok) {
          throw new Error("ファイルの取得に失敗しました");
        }
        const candidates = await candidatesRes.json();
        const parties = await partiesRes.json();
        const elected = await electedRes.json();
        return { candidates, parties, elected };

      } catch (error) {
        console.error("データの読み込みに失敗しました:", error);
        alert("データを読み込めませんでした。");
        return null;
      }
    }

    async function main() {

      /* ==========================================================
         準備) 先行レイアウト初期化（データ読込前）
         ========================================================== */
      const earlyLegendPanel = document.getElementById("legend-panel");
      const earlyFilterPanel = document.getElementById("filter-panel");
      const earlyMobileQuery = window.matchMedia("(max-width: 600px)");
      if (earlyLegendPanel && earlyFilterPanel && earlyMobileQuery.matches) {
        const legendBottom = 15; // モバイルCSSの bottom と合わせる
        const gap = 10;
        const legendHeight = earlyLegendPanel.getBoundingClientRect().height;
        earlyFilterPanel.style.bottom = `${legendBottom + legendHeight + gap}px`;
      }

      /* ==========================================================
         0) データ
         ========================================================== */
      const data = await loadData();
      if (!data) return;

      const pointsData = data.candidates;
      const legendData = data.parties;
      const electedSet = new Set(data.elected);

      const QUESTION_DATA = {
        "Q2. 社会保障負担": ["給付維持×負担増", "給付減×負担減", 5],
        "Q3. 高齢者医療費3割": ["賛成", "反対", 5],
        "Q4. 外国人受入": ["増やす", "減らす", 5],
        "Q5. 消費税": ["増税", "減税・廃止", 4],
        "Q6. 経済政策": ["財政出動", "財政再建", 5],
        "Q7. 経済方針": ["成長重視", "分配重視", 5],
        "Q8. 原発": ["活用", "廃止", 5],
        "Q9-a. 公共事業費": ["増額", "削減", 5],
        "Q9-b. 医療・介護費": ["増額", "削減", 5],
        "Q9-c. 科学技術費": ["増額", "削減", 5],
        "Q9-d. 公務員人件費": ["増額", "削減", 5],
        "Q9-e. 生活保護費": ["増額", "削減", 5],
        "Q9-f. 子育て支援費": ["増額", "削減", 5],
        "Q10. 防衛・安全保障費": ["増額", "減額", 3],
        "Q11. 防衛装備輸出": ["賛成", "反対", 5],
        "Q12. 対米関係強化": ["賛成", "反対", 5],
        "Q13. 対中関係強化": ["賛成", "反対", 5],
        "Q14. 対韓関係強化": ["賛成", "反対", 5],
        "Q15. 皇位継承": ["男系男子維持", "女系容認・天皇制廃止", 4],
        "Q16. 憲法改正": ["賛成", "反対", 5],
        "Q17. 緊急事態条項": ["賛成", "反対", 5],
        "Q18. 夫婦別姓": ["同姓維持", "別姓導入", 3],
        "Q19. 企業団体献金": ["存続", "禁止", 5],
        "Q20. 選挙時のSNS偽情報対策": ["自由尊重", "規制強化", 5],
        "Q21. 選挙時のSNS収益化": ["自由尊重", "規制強化", 5],
        "Q22. 定数削減": ["賛成", "反対", 5],
        "Q23. 政党制": ["二大政党制", "多党制", 5]
      };

      /* ==========================================================
        1) 定数・テーマ
        ========================================================== */
      const THEME = {
        colors: {
          grid: 0xcccccc,
          axisX: 0xff0000,
          axisY: 0x00aa00,
          axisZ: 0x0000ff,
          text: "#333333"
        }, opacity: {
          point: 0.85,
          label: 0.9,
          dimmed: 0.15,
          filteredOutStrong: 0.15,
          lose: 0.3
        }, duration: {
          hover: 0.3,
          camera: 1.5,
          filter: 0.3,
          resetScale: 0.2
        }
      };

      const BASE_URL = "https://www.yomiuri.co.jp/election/shugiin/2026/";
      const UI_SELECTORS = "#about-modal, #legend-panel, #search-container, #about-btn, #search-results, #tooltip, #filter-panel";
      // インデクシング規約:
      // - 配列添字は 0 始まり
      // - 回答スケール値は 1 始まり（UI表示）
      const POLICY_KEYS = Object.keys(QUESTION_DATA);
      const Q_ENTRIES = Object.entries(QUESTION_DATA);
      const QUESTION_INDEX_MAP = new Map(POLICY_KEYS.map((questionKey, questionIndex) => [questionKey, questionIndex]));

      // 中央値（ど真ん中）時の表示文例外
      const MIDPOINT_LABEL_EXCEPTIONS = {
        "Q5. 消費税": "限定的に減税すべき",
        "Q9-a. 公共事業費": "今のままでよい",
        "Q9-b. 医療・介護費": "今のままでよい",
        "Q9-c. 科学技術費": "今のままでよい",
        "Q9-d. 公務員人件費": "今のままでよい",
        "Q9-e. 生活保護費": "今のままでよい",
        "Q9-f. 子育て支援費": "今のままでよい",
        "Q10. 防衛・安全保障費": "GDP比2%程度とすべき",
        "Q15. 皇位継承": "男系ならば女性天皇を認める",
        "Q18. 夫婦別姓": "同姓維持で通称使用機会の拡大"
      };

      /* ==========================================================
        2) テクスチャ補助処理（重いオブジェクトをキャッシュ）
        - 図形テクスチャ: CanvasTexture をキャッシュ
        - 凡例アイコン: dataURL をキャッシュ
        - マテリアル雛形: 生成ヘルパーを使用
        ========================================================== */
      const shapeTextureCache = new Map(); // キー: "shape|#RRGGBB" -> THREE.CanvasTexture
      const shapeDataUrlCache = new Map(); // キー: "shape|#RRGGBB" -> dataURL

      // 当選（赤バラ花冠）合成テクスチャ用キャッシュ
      const electedTextureCache = new Map(); // キー: "shape|#RRGGBB" -> THREE.CanvasTexture

      function loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = url;
        });
      }

      const roseCrownImg = await loadImage("./assets/rose_crown.png");
      const BASE_SHAPE_TEXTURE_SIZE = 64;
      const SHAPE_TEXTURE_SCALE = 6; // 64 * 6 = 384 でさらに高解像度化
      const SHAPE_TEXTURE_SIZE = BASE_SHAPE_TEXTURE_SIZE * SHAPE_TEXTURE_SCALE;
      const ROSE_BADGE_BASE_SIZE = 36;

      // 図形と赤バラ花冠を同一キャンバスに合成
      function drawShapeWithElectedToCanvas(type, color) {
        const canvas = drawShapeToCanvas(type, color);
        const ctx = canvas.getContext("2d");

        const BADGE_SIZE = Math.round(ROSE_BADGE_BASE_SIZE * SHAPE_TEXTURE_SCALE);
        const MARGIN = 0;
        const x = canvas.width - BADGE_SIZE - MARGIN;
        const y = MARGIN;

        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(roseCrownImg, x, y, BADGE_SIZE, BADGE_SIZE);

        return canvas;
      }

      // 当選合成テクスチャを返す（キャッシュ）
      function getElectedShapeTexture(type, color) {
        const key = `${type}|${color}`;
        if (!electedTextureCache.has(key)) {
          const canvas = drawShapeWithElectedToCanvas(type, color);
          const tex = new THREE.CanvasTexture(canvas);
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
          electedTextureCache.set(key, tex);
        }
        return electedTextureCache.get(key);
      }
      // 当選テクスチャ処理ここまで

      function drawShapeToCanvas(type, color) {
        const size = SHAPE_TEXTURE_SIZE;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;

        const ctx = canvas.getContext("2d");
        ctx.fillStyle = color;

        const center = size / 2;
        const radius = size / 2 - 4 * SHAPE_TEXTURE_SCALE;
        const pad = 6 * SHAPE_TEXTURE_SCALE;

        ctx.beginPath();
        if (type === 0) {
          ctx.arc(center, center, radius, 0, Math.PI * 2);
        } else if (type === 1) {
          ctx.rect(pad, pad, size - pad * 2, size - pad * 2);
        } else if (type === 2) {
          ctx.moveTo(center, pad);
          ctx.lineTo(size - pad, size - pad);
          ctx.lineTo(pad, size - pad);
          ctx.closePath();
        } else if (type === 3) {
          ctx.moveTo(center, pad);
          ctx.lineTo(size - pad, center);
          ctx.lineTo(center, size - pad);
          ctx.lineTo(pad, center);
          ctx.closePath();
        } else if (type === 4) {
          const armWidth = 2 * pad;
          ctx.moveTo(center - armWidth, pad); ctx.lineTo(center + armWidth, pad);
          ctx.lineTo(center + armWidth, center - armWidth); ctx.lineTo(size - pad, center - armWidth);
          ctx.lineTo(size - pad, center + armWidth); ctx.lineTo(center + armWidth, center + armWidth);
          ctx.lineTo(center + armWidth, size - pad); ctx.lineTo(center - armWidth, size - pad);
          ctx.lineTo(center - armWidth, center + armWidth); ctx.lineTo(pad, center + armWidth);
          ctx.lineTo(pad, center - armWidth); ctx.lineTo(center - armWidth, center - armWidth);
          ctx.closePath();
        } else {
          ctx.arc(center, center, radius, 0, Math.PI * 2);
        }

        ctx.fill();
        return canvas;
      }

      function getShapeTexture(type, color) {
        const key = `${type}|${color}`;
        if (!shapeTextureCache.has(key)) {
          const canvas = drawShapeToCanvas(type, color);
          const tex = new THREE.CanvasTexture(canvas);
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
          shapeTextureCache.set(key, tex);
        }
        return shapeTextureCache.get(key);
      }

      function getShapeDataUrl(type, color) {
        const key = `${type}|${color}`;
        if (!shapeDataUrlCache.has(key)) {
          const tex = getShapeTexture(type, color);
          shapeDataUrlCache.set(key, tex.image.toDataURL());
        }
        return shapeDataUrlCache.get(key);
      }

      /**
      * 候補者ごとに透明度を変えるため、マテリアルは「共有しない」方針。
      * - テクスチャマップはキャッシュ共有で可
      * - マテリアル自体は個別生成（複製でも可だが、ここでは明示的に生成）
      */
      function createPointMaterial(type, color) {
        return new THREE.SpriteMaterial({
          map: getShapeTexture(type, color),
          transparent: true,
          opacity: THEME.opacity.point
        });
      }

      function createTextTexture(text) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const fontSize = 64;
        ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
        const metrics = ctx.measureText(text);

        canvas.width = metrics.width + 20;
        canvas.height = fontSize + 20;

        // キャンバスのリサイズで描画コンテキストの状態が初期化される
        ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
        ctx.textBaseline = "middle";
        ctx.fillStyle = THEME.colors.text;
        ctx.fillText(text, 10, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        return { texture, width: canvas.width, height: canvas.height };
      }

      /**
      * 軸ラベル用：複数行を重み(サイズ)付きで描画
      * 引数形式: 「文字列と重み」の配列。重みは先頭要素を基準に相対サイズ化
      */
      function createWeightedTextTexture(dataList) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const textureScale = 2;

        const baseVal = dataList.length > 0 ? dataList[0][1] : 1;
        const baseFontSize = 64;

        let maxWidth = 0;
        let totalHeight = 0;

        const lineProps = dataList.map(([text, val]) => {
          const scale = val / baseVal;
          const fontSize = Math.floor(baseFontSize * scale);
          const lineHeight = fontSize * 1.2;

          ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
          const width = ctx.measureText(text).width;

          maxWidth = Math.max(maxWidth, width);
          totalHeight += lineHeight;
          return { text, fontSize, lineHeight, width };
        });

        const logicalWidth = maxWidth + 20;
        const logicalHeight = totalHeight + 20;
        canvas.width = Math.ceil(logicalWidth * textureScale);
        canvas.height = Math.ceil(logicalHeight * textureScale);

        // 高解像度表示向けに内部解像度だけ上げ、見た目サイズは維持する
        ctx.scale(textureScale, textureScale);

        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.textBaseline = "top";

        let y = 10;
        for (const prop of lineProps) {
          ctx.font = `bold ${prop.fontSize}px 'Noto Sans JP', sans-serif`;
          const x = (logicalWidth - prop.width) / 2;
          ctx.fillText(prop.text, x, y);
          y += prop.lineHeight;
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return { texture, width: logicalWidth, height: logicalHeight };
      }

      /* ==========================================================
        3) Three.js 初期設定
        ========================================================== */
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const gridHelper = new THREE.GridHelper(100, 20, THEME.colors.grid, THEME.colors.grid);
      gridHelper.rotation.x = Math.PI / 2;

      // グリッドのチラつき（Zファイティング）軽減
      gridHelper.material.depthWrite = false;
      gridHelper.material.polygonOffset = true;
      gridHelper.material.polygonOffsetFactor = 10;
      gridHelper.material.polygonOffsetUnits = 10;
      scene.add(gridHelper);

      // 軸とラベル
      const origin = new THREE.Vector3(0, 0, 0);
      const axesDefs = [
        { dir: new THREE.Vector3(1, 0, 0), color: THEME.colors.axisX, labelData: [["PC1", 1], ["安全保障強化・成長戦略・伝統的価値観", 0.5]] },
        { dir: new THREE.Vector3(0, 1, 0), color: THEME.colors.axisY, labelData: [["PC2", 1], ["反グローバリズム・右派ポピュリズム", 0.5]] },
        { dir: new THREE.Vector3(0, 0, 1), color: THEME.colors.axisZ, labelData: [["PC3", 1], ["行財政改革・緊縮財政", 0.5]] }
      ];

      for (const def of axesDefs) {
        scene.add(new THREE.ArrowHelper(def.dir, origin, 55, def.color, 2, 1));
        const labelData = createWeightedTextTexture(def.labelData);
        const labelSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: labelData.texture, transparent: true, opacity: 0.8, depthTest: false }));
        labelSprite.position.copy(def.dir.clone().multiplyScalar(58));
        labelSprite.scale.set(labelData.width * 0.03, labelData.height * 0.03, 1);
        labelSprite.renderOrder = 900;
        scene.add(labelSprite);
      }

      // カメラ・レンダラー・コントロール
      const initialCameraPos = { x: 0, y: 0, z: 80 };
      const initialCameraUp = new THREE.Vector3(0, 1, 0);
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);
      camera.up.copy(initialCameraUp);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      // 既定（シンプル）動作:
      // - PC左ドラッグ: OrbitControls既定の回転
      // - スマホ1本指: OrbitControls既定の回転
      // controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
      // controls.touches.ONE = THREE.TOUCH.ROTATE;
      //
      // 今回はPC左ドラッグとスマホ1本指ドラッグを同一操作感にするため、
      // 既定回転を無効化して独自の回転処理に切り替える
      controls.mouseButtons.LEFT = -1;
      controls.touches.ONE = -1;
      // 起動時ビューの厳密復元用スナップショット
      const initialViewState = {
        cameraPosition: camera.position.clone(),
        cameraUp: camera.up.clone(),
        target: controls.target.clone()
      };

      // PCホイールズームは、カーソル位置を基準に拡大縮小する
      function zoomTowardCursor(event) {
        // タッチパッドのピンチは既存挙動に任せる
        if (event.ctrlKey) return;

        const rect = renderer.domElement.getBoundingClientRect();
        const ndcX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const ndcY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        const pointerNdc = new THREE.Vector2(ndcX, ndcY);
        const pointerRaycaster = new THREE.Raycaster();
        pointerRaycaster.setFromCamera(pointerNdc, camera);

        const viewDir = new THREE.Vector3();
        camera.getWorldDirection(viewDir);
        const zoomPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(viewDir, controls.target);
        const zoomPivot = new THREE.Vector3();
        if (!pointerRaycaster.ray.intersectPlane(zoomPlane, zoomPivot)) return;

        event.preventDefault();
        event.stopPropagation();

        const zoomFactor = event.deltaY < 0 ? 0.9 : 1.1;
        const offsetFromPivot = camera.position.clone().sub(zoomPivot).multiplyScalar(zoomFactor);
        const targetOffsetFromPivot = controls.target.clone().sub(zoomPivot).multiplyScalar(zoomFactor);

        const nextCameraPos = zoomPivot.clone().add(offsetFromPivot);
        const nextTargetPos = zoomPivot.clone().add(targetOffsetFromPivot);

        const nextDistance = nextCameraPos.distanceTo(nextTargetPos);
        if (nextDistance < controls.minDistance || nextDistance > controls.maxDistance) return;

        camera.position.copy(nextCameraPos);
        controls.target.copy(nextTargetPos);
        controls.update();
      }

      renderer.domElement.addEventListener("wheel", zoomTowardCursor, { passive: false, capture: true });

      // PC左ドラッグ/スマホ1本指ドラッグ:
      // - 上下移動: 画面の水平軸まわりで回転
      // - 左右移動: 常にZ軸まわりで回転
      let isPrimaryDragRotating = false;
      let primaryDragPointerId = null;
      let lastPrimaryX = 0;
      let lastPrimaryY = 0;
      const activeTouchPointerIds = new Set();

      function stopPrimaryDragRotate() {
        if (!isPrimaryDragRotating) return;
        const pointerId = primaryDragPointerId;
        isPrimaryDragRotating = false;
        primaryDragPointerId = null;
        if (pointerId !== null && renderer.domElement.hasPointerCapture(pointerId)) {
          renderer.domElement.releasePointerCapture(pointerId);
        }
      }

      function startPrimaryDragRotate(event) {
        const isMousePrimary = event.pointerType === "mouse" && event.button === 0;
        const isTouch = event.pointerType === "touch";
        if (!isMousePrimary && !isTouch) return;

        if (isTouch) {
          activeTouchPointerIds.add(event.pointerId);
          if (activeTouchPointerIds.size > 1) {
            // 2本指以上は既存のOrbitControls操作に任せる
            stopPrimaryDragRotate();
            return;
          }
        }

        isPrimaryDragRotating = true;
        primaryDragPointerId = event.pointerId;
        lastPrimaryX = event.clientX;
        lastPrimaryY = event.clientY;
        mouseDownPos = { x: event.clientX, y: event.clientY };

        renderer.domElement.setPointerCapture(event.pointerId);
        event.preventDefault();
        event.stopPropagation();
      }

      function movePrimaryDragRotate(event) {
        if (!isPrimaryDragRotating) return;
        if (event.pointerId !== primaryDragPointerId) return;
        if (event.pointerType === "touch" && activeTouchPointerIds.size !== 1) return;

        const dx = event.clientX - lastPrimaryX;
        const dy = event.clientY - lastPrimaryY;
        lastPrimaryX = event.clientX;
        lastPrimaryY = event.clientY;

        const verticalRotateSpeed = (2 * Math.PI) / Math.max(renderer.domElement.clientHeight, 1);
        const rollRotateSpeed = (2 * Math.PI) / Math.max(renderer.domElement.clientWidth, 1);

        // 上下移動: 画面の水平軸（カメラのローカルX軸）まわりで回転
        const screenHorizontalAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
        const pitchQuat = new THREE.Quaternion().setFromAxisAngle(screenHorizontalAxis, -dy * verticalRotateSpeed);
        const offset = camera.position.clone().sub(controls.target).applyQuaternion(pitchQuat);
        camera.position.copy(controls.target).add(offset);
        camera.up.applyQuaternion(pitchQuat);

        // 左右移動: 常にワールドZ軸まわりで回転
        const worldZAxis = new THREE.Vector3(0, 0, 1);
        const yawQuat = new THREE.Quaternion().setFromAxisAngle(worldZAxis, -dx * rollRotateSpeed);
        const yawOffset = camera.position.clone().sub(controls.target).applyQuaternion(yawQuat);
        camera.position.copy(controls.target).add(yawOffset);
        camera.up.applyQuaternion(yawQuat);

        controls.update();
        event.preventDefault();
        event.stopPropagation();
      }

      function endPrimaryDragRotate(event) {
        if (event.pointerType === "touch") {
          activeTouchPointerIds.delete(event.pointerId);
        }
        if (event.pointerId === primaryDragPointerId) {
          stopPrimaryDragRotate();
        }
      }

      renderer.domElement.addEventListener("pointerdown", startPrimaryDragRotate, true);
      window.addEventListener("pointermove", movePrimaryDragRotate, true);
      window.addEventListener("pointerup", endPrimaryDragRotate, true);
      window.addEventListener("pointercancel", endPrimaryDragRotate, true);

      /* ==========================================================
        4) 候補者オブジェクト生成（点・ラベル・ツールチップ・回答）
        ========================================================== */
      const candidateObjects = [];
      const targetSprites = [];

      function buildAnswers(rawAnswerArray) {
        const answers = {};
        if (!Array.isArray(rawAnswerArray)) {
          for (const key of POLICY_KEYS) answers[key] = null;
          return answers;
        }
        for (let i = 0; i < POLICY_KEYS.length; i++) {
          const raw = rawAnswerArray[i];
          answers[POLICY_KEYS[i]] = raw === "-" || raw === null || raw === undefined || raw === "" ? null : Number(raw);
        }
        return answers;
      }

      function buildTooltipHtml(candidate) { // 27行前後のHTMLになるため、ここは「事前生成」して userData に固定する（ホバーごとの生成を避ける）
        let html = "";
        for (const [questionKey, params] of Q_ENTRIES) {
          const answerIndex = QUESTION_INDEX_MAP.get(questionKey);
          if (answerIndex === undefined) continue;

          const label = questionKey;
          const [textLow, textHigh, maxScore] = params;
          const answerValue = candidate.answer?.[answerIndex];
          if (answerValue === "-") {
            html += `${label}: (未回答)<br>`;
            continue;
          }

          const threshold = (maxScore + 1) / 2;
          if (answerValue > threshold) {
            html += `${label}: ${textHigh} (${answerValue}/${maxScore})<br>`;
            continue;
          }
          if (answerValue < threshold) {
            html += `${label}: ${textLow} (${answerValue}/${maxScore})<br>`;
            continue;
          }

          // ど真ん中のときは質問ごとの例外表示を優先する
          let content = "どちらともいえない";
          if (MIDPOINT_LABEL_EXCEPTIONS[label]) content = MIDPOINT_LABEL_EXCEPTIONS[label];
          html += `${label}: ${content} (${answerValue}/${maxScore})<br>`;
        }

        return `
                <strong>${candidate.name}</strong>
                <div class="tooltip-party">${candidate.party}</div>
                <div class="tooltip-answers">${html}</div>
                `;
      }

      for (const candidate of pointsData) {
        const sprite = new THREE.Sprite(createPointMaterial(candidate.shape, candidate.color));
        sprite.position.set(candidate.x, candidate.y, candidate.z);

        // ラベル（候補者名）: 個別テクスチャ（候補者数が多いとメモリ増）
        const textData = createTextTexture(candidate.name);
        const label = new THREE.Sprite(
          new THREE.SpriteMaterial({
            map: textData.texture,
            transparent: true,
            opacity: THEME.opacity.label,
            depthTest: false
          })
        );
        label.position.set(candidate.x, candidate.y + 0.9, candidate.z);
        label.scale.set(textData.width * 0.012, textData.height * 0.012, 1);
        label.renderOrder = 999;

        sprite.userData = {
          url: candidate.url,
          html: buildTooltipHtml(candidate)
        };

        scene.add(sprite);
        scene.add(label);

        candidateObjects.push({
          name: candidate.name,
          party: candidate.party,
          sprite,
          label,
          position: new THREE.Vector3(candidate.x, candidate.y, candidate.z),
          answers: buildAnswers(candidate.answer),

          // 図形・色・当選フラグを保持して、あとで差し替える
          shape: candidate.shape,
          color: candidate.color,
          elected: electedSet.has(candidate.name)
        });

        targetSprites.push(sprite);
      }

      /* ==========================================================
        5) DOM参照
        ========================================================== */
      const legendDiv = document.getElementById("legend-panel");
      const tooltip = document.getElementById("tooltip");
      const modal = document.getElementById("about-modal");

      const searchInput = document.getElementById("search-input");
      const searchResults = document.getElementById("search-results");

      const issueSelect = document.getElementById("issue-select");
      const valueRange = document.getElementById("value-range");
      const valueRangeOptions = document.getElementById("value-range-options");
      const labelLow = document.getElementById("label-low");
      const labelHigh = document.getElementById("label-high");
      const filterControl = document.getElementById("filter-control");
      const filterReset = document.getElementById("filter-reset");
      const filterPanel = document.getElementById("filter-panel");

      const electedToggle = document.getElementById("elected-toggle");

      /* ==========================================================
        6) フィルター（政党 AND 政策）
        - activeParty: 凡例クリック
        - currentPolicyKey: セレクトで設定
        ========================================================== */
      let activeParty = null;
      let currentPolicyKey = null;
      // 当選表示の反映
      let showElected = electedToggle?.checked ?? false;

      function applyElectedDecoration() {
        for (const obj of candidateObjects) {
          if (!obj.elected) continue;

          const nextMap = showElected
            ? getElectedShapeTexture(obj.shape, obj.color)
            : getShapeTexture(obj.shape, obj.color);

          if (obj.sprite.material.map !== nextMap) {
            obj.sprite.material.map = nextMap;
            obj.sprite.material.needsUpdate = true;
          }
        }
      }

      electedToggle?.addEventListener("change", () => {
        showElected = electedToggle.checked;
        applyElectedDecoration();
        applyCombinedFilter();
      });

      function tweenOpacity(material, targetOpacity) {
        // 変化がない場合はアニメーション処理を抑制（大量候補者でも軽くなる）
        if (Math.abs(material.opacity - targetOpacity) < 0.001) {
          return;
        }
        gsap.to(material, {
          opacity: targetOpacity,
          duration: THEME.duration.filter,
          ease: "power2.out"
        });
      }

      function applyCombinedFilter() {
        const hasParty = !!activeParty;
        const hasPolicy = !!currentPolicyKey;
        const targetVal = hasPolicy ? Number(valueRange.value) : null;
        for (const obj of candidateObjects) {
          const partyMatch = !hasParty || obj.party === activeParty;
          let policyMatch = true;
          if (hasPolicy) {
            const candidateVal = obj.answers[currentPolicyKey];
            policyMatch = candidateVal !== null && candidateVal === targetVal;
          }
          const isMatch = partyMatch && policyMatch; // 表示強度
          let spriteOpacity, labelOpacity;
          if (!hasParty && !hasPolicy) {
            spriteOpacity = THEME.opacity.point;
            labelOpacity = THEME.opacity.label;
          } else if (hasPolicy) {
            spriteOpacity = isMatch ? 1 : THEME.opacity.filteredOutStrong;
            labelOpacity = isMatch ? 1 : THEME.opacity.filteredOutStrong;
          } else {
            spriteOpacity = isMatch ? THEME.opacity.point : THEME.opacity.dimmed;
            labelOpacity = isMatch ? THEME.opacity.label : THEME.opacity.dimmed;
          }

          if (showElected && !obj.elected) {
            spriteOpacity = Math.min(spriteOpacity, THEME.opacity.lose);
            labelOpacity  = Math.min(labelOpacity, THEME.opacity.lose);
          }
          
          tweenOpacity(obj.sprite.material, spriteOpacity);
          tweenOpacity(obj.label.material, labelOpacity);
        }
      }

      applyElectedDecoration();
      applyCombinedFilter();

      /* ==========================================================
        7) 凡例（政党フィルター）-
        querySelectorAll を毎回実行しないよう、要素配列を保持
        ========================================================== */
      const legendItemEls = [];
      function setLegendSelected(targetEl) {
        for (const el of legendItemEls) el.classList.remove("selected");
        if (targetEl) targetEl.classList.add("selected");
      }

      function renderLegend() {
        const frag = document.createDocumentFragment();
        for (const item of legendData) {

          const legendItemEl = document.createElement("div");
          legendItemEl.className = "legend-item";

          const iconUrl = getShapeDataUrl(item.style.shape, item.style.color);
          legendItemEl.innerHTML = `<img src="${iconUrl}" class="legend-icon" alt=""><span>${item.party}</span>`;

          legendItemEl.addEventListener("click", () => {
            const isSame = activeParty === item.party;
            activeParty = isSame ? null : item.party;

            setLegendSelected(isSame ? null : legendItemEl);
            applyCombinedFilter();
          });

          legendItemEls.push(legendItemEl);
          frag.appendChild(legendItemEl);
        }

        legendDiv.appendChild(frag);
      }
      renderLegend();

      /* ==========================================================
        8) ツールチップとポインター操作
        ========================================================== */
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      let hoveredSprite = null;
      let currentData = null;
      let mouseDownPos = { x: 0, y: 0 };

      function pickSprite(clientX, clientY) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(targetSprites, false);
        return intersects.length ? intersects[0].object : null;
      }

      function updateTooltipPos(clientX, clientY) {
        const tooltipWidth = tooltip.getBoundingClientRect().width;
        const xPos = (clientX + tooltipWidth > window.innerWidth) ? clientX - tooltipWidth : clientX + 15;

        tooltip.style.left = `${xPos}px`;
        tooltip.style.top = `${clientY - 40}px`;
      }

      function showTooltip(data) {
        tooltip.innerHTML = data.html;
        tooltip.style.display = "block";
      }

      function hideTooltip() {
        tooltip.style.display = "none";
        document.body.style.cursor = "default";
      }

      function jumpToUrl(data) {
        if (data?.url) window.open(BASE_URL + data.url, "_blank", "noopener");
      }

      function resetScale() {
        if (!hoveredSprite) return;
        gsap.to(hoveredSprite.scale, { x: 1, y: 1, duration: THEME.duration.resetScale });
        hoveredSprite = null;
      }

      window.addEventListener("pointerdown", (e) => {
        if (e.target.closest(UI_SELECTORS)) return;
        mouseDownPos = { x: e.clientX, y: e.clientY };
      });

      // PCホイールクリック（中ボタン）で表示を初期化
      window.addEventListener("pointerdown", (e) => {
        const isMiddleMouse = e.pointerType === "mouse" && e.button === 1;
        if (!isMiddleMouse) return;
        if (e.target.closest(UI_SELECTORS)) return;
        if (!(e.target === renderer.domElement || renderer.domElement.contains(e.target))) return;

        e.preventDefault();
        e.stopPropagation();
        hideTooltip();
        resetScale();
        resetView();
      }, true);

      // PCのホバー処理（タッチ操作ではホバーしない）
      window.addEventListener("pointermove", (e) => {
        if (e.pointerType === "touch") return;

        if (e.target.closest(UI_SELECTORS) || e.buttons > 0) {
          hideTooltip();
          return;
        }

        const hit = pickSprite(e.clientX, e.clientY);
        if (!hit) {
          hideTooltip();
          resetScale();
          return;
        }

        if (hoveredSprite !== hit) {
          resetScale();
          hoveredSprite = hit;
          gsap.to(hit.scale, { x: 1.5, y: 1.5, duration: THEME.duration.hover, ease: "power3.out" });
        }

        currentData = hit.userData;
        showTooltip(currentData);
        updateTooltipPos(e.clientX, e.clientY);
        document.body.style.cursor = "pointer";
      });

      // PCはクリックで詳細を開く。タッチ操作はタップでツールチップ表示
      window.addEventListener("pointerup", (e) => {
        if (e.target.closest(UI_SELECTORS)) return;

        const dist = Math.hypot(e.clientX - mouseDownPos.x, e.clientY - mouseDownPos.y);
        if (dist > 5) return;

        const hit = pickSprite(e.clientX, e.clientY);
        if (!hit) {
          if (e.pointerType === "touch") {
            hideTooltip();
            resetScale();
          }
          return;
        }

        const data = hit.userData;

        if (e.pointerType === "touch") {
          // タップ: ツールチップを表示
          if (hoveredSprite !== hit) {
            resetScale();
            hoveredSprite = hit;
            gsap.to(hit.scale, { x: 1.5, y: 1.5, duration: THEME.duration.hover });
          }
          currentData = data;
          showTooltip(data);
          updateTooltipPos(e.clientX, e.clientY);
        } else {
          // クリック: 詳細ページを開く
          jumpToUrl(data);
        }
      });

      // ツールチップのタップで詳細ページを開く（モバイル）
      tooltip.addEventListener("pointerup", (e) => {
        e.stopPropagation();
        if (currentData) jumpToUrl(currentData);
      });

      /* ==========================================================
        9) 描画ループ
        ========================================================== */
      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.005;
        const pulseScale = 1.4 + Math.sin(time) * 0.4;

        for (const obj of candidateObjects) {
          if (obj.sprite === hoveredSprite) continue;

          const targetScale = (activeParty && obj.party === activeParty) ? pulseScale : 1;
          if (Math.abs(obj.sprite.scale.x - targetScale) > 0.01) {
            obj.sprite.scale.set(targetScale, targetScale, 1);
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      /* ==========================================================
        10) 説明モーダル
        ========================================================== */
      document.getElementById("about-btn").addEventListener("click", () => {
        modal.style.display = "flex";
      });
      document.getElementById("close-modal").addEventListener("click", () => {
        modal.style.display = "none";
      });
      window.addEventListener("click", (e) => {
        if (e.target === modal) modal.style.display = "none";
      });

      /* ==========================================================
        11) 検索
        ========================================================== */
      searchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim();
        searchResults.innerHTML = "";

        if (!query) {
          searchResults.style.display = "none";
          return;
        }

        const matches = candidateObjects.filter((candidateObj) => candidateObj.name.includes(query) || candidateObj.party.includes(query));
        if (matches.length === 0) {
          searchResults.style.display = "none";
          return;
        }

        const frag = document.createDocumentFragment();
        for (const match of matches) {
          const li = document.createElement("li");
          li.className = "search-item";
          li.innerHTML = `<span>${match.name}</span><span class="search-party">${match.party}</span>`;

          li.addEventListener("click", () => {
            focusCandidate(match);
            searchResults.style.display = "none";
            searchInput.value = match.name;
          });

          frag.appendChild(li);
        }

        searchResults.appendChild(frag);
        searchResults.style.display = "block";
      });

      // エンターキー: 先頭項目へ移動。未入力時は表示リセット
      searchInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;

        const query = searchInput.value.trim();
        if (!query) {
          resetView();
          searchInput.blur();
          return;
        }

        const first = searchResults.querySelector(".search-item");
        if (first) {
          first.click();
          searchInput.blur();
        }
      });

      function focusCandidate(candidateObj) {
        const targetPos = candidateObj.position;

        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z + 15,
          duration: THEME.duration.camera,
          ease: "power3.inOut",
          onUpdate: () => controls.update()
        });

        gsap.to(controls.target, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: THEME.duration.camera,
          ease: "power3.inOut"
        });
      }

      function resetView() {
        // 起動時と同じビューへ戻す（camera.position / camera.up / controls.target）
        gsap.killTweensOf(camera.position);
        gsap.killTweensOf(controls.target);
        gsap.killTweensOf(camera.up);

        const onUpdateView = () => {
          camera.up.normalize();
          controls.update();
        };

        gsap.to(camera.position, {
          x: initialViewState.cameraPosition.x,
          y: initialViewState.cameraPosition.y,
          z: initialViewState.cameraPosition.z,
          duration: THEME.duration.camera,
          ease: "power3.inOut",
          onUpdate: onUpdateView
        });

        gsap.to(controls.target, {
          x: initialViewState.target.x,
          y: initialViewState.target.y,
          z: initialViewState.target.z,
          duration: THEME.duration.camera,
          ease: "power3.inOut",
          onUpdate: onUpdateView
        });

        gsap.to(camera.up, {
          x: initialViewState.cameraUp.x,
          y: initialViewState.cameraUp.y,
          z: initialViewState.cameraUp.z,
          duration: THEME.duration.camera,
          ease: "power3.inOut",
          onUpdate: onUpdateView
        });
      }

      /* ==========================================================
        12) 政策フィルターUI
        ========================================================== */
      function setFilterControlEnabled(enabled) {
        filterControl.classList.toggle("is-disabled", !enabled);
      }

      function resetFilter() {
        issueSelect.value = "";
        currentPolicyKey = null;

        setFilterControlEnabled(false);
        labelLow.textContent = "---";
        labelHigh.textContent = "---";
        valueRangeOptions.replaceChildren();

        applyCombinedFilter();
      }

      function onIssueChange() {
        const selectedPolicyKey = issueSelect.value;
        if (!selectedPolicyKey || !QUESTION_DATA[selectedPolicyKey]) {
          resetFilter();
          return;
        }

        const [low, high, scale] = QUESTION_DATA[selectedPolicyKey];
        currentPolicyKey = selectedPolicyKey;

        setFilterControlEnabled(true);

        labelLow.textContent = `1: ${low}`;
        labelHigh.textContent = `${scale}: ${high}`;

        valueRange.max = String(scale);
        valueRange.value = String(Math.ceil(scale / 2));
        const optionFrag = document.createDocumentFragment();
        for (let i = 1; i <= scale; i += 1) {
          const option = document.createElement("option");
          option.value = String(i);
          option.label = String(i);
          optionFrag.appendChild(option);
        }
        valueRangeOptions.replaceChildren(optionFrag);

        applyCombinedFilter();
      }

      function onValueChange() {
        applyCombinedFilter();
      }

      function initFilterUI() {
        // セレクトの選択肢はまとめて追加（再レイアウト抑制）
        const frag = document.createDocumentFragment();
        for (const key of POLICY_KEYS) {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = key;
          frag.appendChild(opt);
        }
        const placeholder = issueSelect.querySelector('option[value=""]')?.cloneNode(true)
          ?? new Option("質問項目を選択...", "");
        issueSelect.replaceChildren(placeholder, frag);

        issueSelect.addEventListener("change", onIssueChange);
        valueRange.addEventListener("input", onValueChange);
        filterReset.addEventListener("click", resetFilter);
      }
      initFilterUI();

      /* ==========================================================
        13) モバイル: ヘッダータップで開閉 + 動的な積み上げ配置
        ========================================================== */
      const mqMobile = window.matchMedia("(max-width: 600px)");
      const legendHeaderEl = legendDiv.querySelector(".legend-header");
      const filterHeaderEl = filterPanel.querySelector(".filter-header");

      function updateMobileLayout() {
        if (!mqMobile.matches) {
          filterPanel.style.bottom = "";
          return;
        }

        // 下側の凡例パネル高さに応じて、フィルターパネルを上へ積む
        const legendBottom = 15; // CSSのmobile bottomに合わせる
        const gap = 10;
        const legendH = legendDiv.getBoundingClientRect().height;

        filterPanel.style.bottom = `${legendBottom + legendH + gap}px`;
      }

      function setMinimized(panel, minimized) {
        panel.classList.toggle("minimized", minimized);
        updateMobileLayout();
      }

      function toggleMinimized(panel) {
        setMinimized(panel, !panel.classList.contains("minimized"));
      }

      // 凡例: タイトルをタップして開閉
      legendHeaderEl?.addEventListener("click", (e) => {
        if (!mqMobile.matches) return;
        e.stopPropagation();
        toggleMinimized(legendDiv);
      });

      // フィルター: ヘッダーをタップして開閉（リセットボタンは除外）
      filterHeaderEl?.addEventListener("click", (e) => {
        if (!mqMobile.matches) return;
        if (e.target.closest("#filter-reset")) return;
        toggleMinimized(filterPanel);
      });

      function applyResponsivePanels() {
        if (mqMobile.matches) {
          setMinimized(legendDiv, true);
          setMinimized(filterPanel, true);
        } else {
          setMinimized(legendDiv, false);
          setMinimized(filterPanel, false);
          filterPanel.style.bottom = "";
        }
      }

      applyResponsivePanels();

      // 旧方式向けの互換対応
      if (mqMobile.addEventListener) mqMobile.addEventListener("change", applyResponsivePanels);
      else mqMobile.addListener(applyResponsivePanels);

      window.addEventListener("resize", updateMobileLayout);
    }

    main();
  </script>

 	<script src="../logger.js"></script>

</body>

</html>
