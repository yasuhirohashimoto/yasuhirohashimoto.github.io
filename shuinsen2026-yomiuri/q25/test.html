<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>衆院選2026 候補者：政党党首好感度マップ（PCA版）</title>

  <!-- =========================
       Styles
       ========================= -->
  <style>
    /* -------------------------
       1) Design tokens
       ------------------------- */
    :root {
      --bg-glass: rgba(255, 255, 255, 0.9);
      --bg-glass-dark: rgba(0, 0, 0, 0.8);
      --primary-color: #1f77b4;
      --border-color: rgba(0, 0, 0, 0.1);
      --text-main: #333;
      --text-sub: #666;
      --accent-blue: #4fc3f7;

      --radius-lg: 16px;
      --radius-md: 8px;
      --radius-sm: 4px;

      --shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);

      --z-ui: 1000;
      --z-modal: 2000;
      --z-tooltip: 3000;
    }

    /* -------------------------
       2) Base
       ------------------------- */
    * { box-sizing: border-box; }

    body {
      margin: 0;
      overflow: hidden;
      font-family: "Noto Sans JP", "Meiryo", sans-serif;
      background-color: #f8f9fa;
      color: var(--text-main);
    }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 10px; }
    ::-webkit-scrollbar-thumb:hover { background: #999; }

    /* -------------------------
       3) Search UI
       ------------------------- */
    #search-container {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: var(--z-ui);
      width: 320px;
    }

    #search-input {
      width: 100%;
      padding: 12px 20px;
      border-radius: 30px;
      border: 1px solid var(--border-color);
      background: var(--bg-glass);
      backdrop-filter: blur(8px);
      font-size: 16px;
      box-shadow: var(--shadow);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    #search-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(31, 119, 180, 0.2);
    }

    #search-results {
      list-style: none;
      margin: 8px 0 0 0;
      padding: 8px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow);
      max-height: 300px;
      overflow-y: auto;
      display: none;
      border: 1px solid var(--border-color);
    }

    .search-item {
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition);
    }

    .search-item:hover { background: rgba(0, 0, 0, 0.05); }

    .search-party {
      font-size: 11px;
      color: var(--text-sub);
      background: rgba(0, 0, 0, 0.08);
      padding: 2px 8px;
      border-radius: 12px;
    }

    /* -------------------------
       4) Coordinate selector
       ------------------------- */
      #coord-selector {
        position: absolute;
        left: 20px;
        bottom: 30px;
        z-index: var(--z-ui);
        background: transparent;
        border: none;
        border-radius: 0;
        padding: 0;
        box-shadow: none;
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 196px;
        font-size: 12px;
      color: var(--text-main);
    }

      #coord-select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 20px;
        background: white;
        font-size: 14px;
        outline: none;
        cursor: pointer;
      }

    /* -------------------------
       4) Legend panel
       ------------------------- */
    #legend {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      padding: 20px;
      border-radius: var(--radius-lg);
      min-width: 220px;
      max-height: 400px;
      overflow-y: auto;
      box-shadow: var(--shadow);
      font-size: 14px;
      border: 1px solid var(--border-color);
      z-index: var(--z-ui);
    }

    .legend-title {
      font-weight: bold;
      margin-bottom: 12px;
      font-size: 16px;
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      cursor: pointer;
      padding: 6px 10px;
      transition: var(--transition);
      border-left: 4px solid transparent;
      border-radius: var(--radius-sm);
      -webkit-tap-highlight-color: transparent;
    }

    .legend-item:hover { background: rgba(0, 0, 0, 0.05); }

    .legend-item.selected {
      background-color: rgba(0, 0, 0, 0.08);
      border-left: 4px solid var(--primary-color);
      font-weight: bold;
    }

    .legend-icon {
      width: 18px;
      height: 18px;
      margin-right: 12px;
      border-radius: 2px;
    }

    /* -------------------------
       5) About button & modal
       ------------------------- */
    #about-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      background: var(--bg-glass);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      font-weight: bold;
      cursor: pointer;
      z-index: var(--z-ui);
      font-size: 20px;
      color: var(--text-sub);
      box-shadow: var(--shadow);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: var(--transition);
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }

    @media (hover: hover) {
      #about-btn:hover {
        background: var(--primary-color);
        color: white;
        transform: scale(1.05);
      }
    }

    #about-btn:active { transform: scale(0.95); }

    #about-modal {
      display: none;
      position: fixed;
      inset: 0; /* top/left/width/heightの代替 */
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      z-index: var(--z-modal);
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    #about-content {
      color: var(--text-main);
      background: white;
      padding: 40px;
      border-radius: var(--radius-lg);
      max-width: 640px;
      width: 100%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      position: relative;
      line-height: 1.8;
    }

    #about-content h2 {
      margin: 0 0 24px 0;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border-color);
      font-size: 24px;
      text-align: center;
    }

    #about-content h3 {
      font-size: 18px;
      margin-top: 32px;
      margin-bottom: 12px;
    }

    #close-modal {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 28px;
      cursor: pointer;
      color: #bbb;
      transition: var(--transition);
      -webkit-tap-highlight-color: transparent;
    }

    #close-modal:hover { color: var(--text-main); transform: rotate(90deg); }

    /* -------------------------
       6) Tooltip
       ------------------------- */
    #tooltip {
      position: absolute;
      display: none;
      background: var(--bg-glass-dark);
      backdrop-filter: blur(8px);
      color: #fff;
      padding: 14px;
      border-radius: var(--radius-md);
      font-size: 13px;
      z-index: var(--z-tooltip);
      line-height: 1.6;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.1);
      pointer-events: none; /* PCはスルー、モバイルではmediaでタップ可に */
      min-width: 200px;
    }

    #tooltip strong {
      font-size: 16px;
      display: block;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 4px;
    }

    .tooltip-party {
      font-size: 12px;
      margin-bottom: 8px;
      color: #ddd;
    }

    .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      color: #ddd;
    }

    .tooltip-val {
      font-family: "Roboto Mono", monospace;
      color: var(--accent-blue);
      font-weight: bold;
    }

    /* -------------------------
       7) Mobile
       ------------------------- */
    @media (max-width: 600px) {
      #search-container { width: calc(100% - 80px); top: 15px; left: 15px; }

      #coord-selector {
        left: 15px;
        bottom: 15px;
        min-width: 170px;
        font-size: 11px;
      }

      #legend {
        left: 15px;
        right: 15px;
        bottom: 15px;
        max-height: 200px;
        padding: 12px;
      }

      #about-content { padding: 30px 20px; width: 95%; font-size: 14px; }
      #about-btn { top: 15px; right: 15px; width: 40px; height: 40px; }

      /* モバイルはツールチップをタップ対象にする */
      #tooltip { pointer-events: auto; cursor: pointer; }
    }
  </style>

  <!-- =========================
       Libraries
       ========================= -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
  <!-- Search -->
  <div id="search-container">
    <input type="text" id="search-input" placeholder="候補者名・政党名で検索" />
    <ul id="search-results"></ul>
  </div>

  <!-- Tooltip -->
  <div id="tooltip"></div>

  <!-- Coordinate selector -->
  <div id="coord-selector">
    <select id="coord-select" aria-label="座標系を選択">
      <option value="pc">PCA</option>
      <option value="pcn">PCA（L2正則化）</option>
      <option value="ic">ICA</option>
      <option value="um">UMAP</option>
    </select>
  </div>

  <!-- About -->
  <button id="about-btn" title="このサイトについて">?</button>

  <div id="about-modal">
    <div id="about-content">
      <span id="close-modal">&times;</span>
      <h2>このマップについて</h2>
      <p>
        この3Dマップは、衆議院選挙（2026年）における各候補者の「政党党首に対する好感度」のアンケートデータを分析し、回答傾向が似ている候補者同士が近くになるように配置したものです。
      </p>

      <h3>データ出典</h3>
      <p>
        <a href="https://www.yomiuri.co.jp/election/shugiin/2026candidates/" target="_blank" rel="noopener noreferrer">
          読売新聞オンライン「衆院選2026　立候補者一覧」
        </a>
      </p>

      <h3>使用データと集計方法</h3>
      <ul>
        <li><strong>対象設問（Q25）:</strong><br>
          「次にあげる政党の党首に対する、あなたの気持ちをお答えください。高市早苗（自民）、吉村洋文（維新）、野田佳彦（中道改革）、玉木雄一郎（国民）、田村智子（共産）、山本太郎（れいわ）、神谷宗幣（参政）、百田尚樹（保守）、福島瑞穂（社民）、安野貴博（みらい）（最も好感を持つ場合は10、最も反感を持つ場合は0、好感も反感も持たない場合は5）」
        </li>
        <li><strong>データ処理:</strong><br>
          元のスケール「0（反感）〜10（好感）」を、「&#8722;1 〜 +1」の範囲に再スケーリングして使用。「回答なし」は、どちらでもない「0（ニュートラル）」として処理しています。<br>
          ※ 完全に同一な値を持つ候補者の位置をずらして見やすくするために、元ベクトルの各成分に平均0、標準偏差0.05のガウシアンノイズを加えています。
        </li>
      </ul>

      <h3>分析手法</h3>
      <p>10次元（党首10名）で集計した回答データを、目的に応じて4種類の3次元座標系で可視化しています。</p>
      <ul>
        <li><strong>主成分分析（PCA）:</strong> 分散を基準に3軸へ圧縮する線形写像です。</li>
        <li><strong>主成分分析（PCA - L2正則化付き）:</strong> PCAの座標をL2ノルムの補正条件で安定化した表現です。</li>
        <li><strong>独立成分分析（ICA）:</strong> 相互に独立な成分を抽出し、独立性の高い軸を3次元で可視化します。</li>
        <li><strong>一様多様体近似と射影（UMAP）:</strong> 高次元データの近傍構造を保ちながら低次元へ写像する非線形手法です。</li>
      </ul>

      <h3>操作方法</h3>
      <ul>
        <li><strong>回転：</strong> 指一本でドラッグ (PC：左ドラッグ)</li>
        <li><strong>ズーム：</strong> 二本指でピンチ (PC：ホイール)</li>
        <li><strong>移動：</strong> 二本指でスワイプ (PC：右ドラッグ)</li>
        <li><strong>詳細：</strong> 点をタップ (PC：ホバー)</li>
      </ul>
    </div>
  </div>

  <!-- Legend -->
  <div id="legend">
    <div class="legend-title">政党一覧</div>
  </div>

  <!-- =========================
       Script
       ========================= -->
  <script>
    async function loadData() {
        try {
            const [candidatesRes, partiesRes] = await Promise.all([
                fetch('./data/candidates.json'),
                fetch('./data/parties.json')
            ]);
            if (!candidatesRes.ok || !partiesRes.ok) {
                throw new Error("ファイルの取得に失敗しました");
            }     
            const candidates = await candidatesRes.json();
            const parties = await partiesRes.json();
            return { candidates, parties };
    
        } catch (error) {
            console.error("データの読み込みに失敗しました:", error);
            alert("データを読み込めませんでした。");
            return null;
        }
    }

    async function main() {
      
      /* ==========================================================
         0) Data
         ========================================================== */
      const data = await loadData();  
      if (!data) return;
  
      const pointsData = data.candidates;
      const legendData = data.parties;

      const COORDINATE_SETS = {
        pc:  { x: "pc1",  y: "pc2",  z: "pc3",  labels: ["pc1", "pc2", "pc3"] },
        pcn: { x: "pcn1", y: "pcn2", z: "pcn3", labels: ["pcn1", "pcn2", "pcn3"] },
        um:  { x: "um1",  y: "um2",  z: "um3",  labels: ["x", "y", "z"] },
        ic:  { x: "ic1",  y: "ic2",  z: "ic3",  labels: ["ic1", "ic2", "ic3"] }
      };

      let activeCoordKey = "pc";
      const LABEL_Y_OFFSET = 0.9;
        
      // tooltip表示順（Q25の順序に合わせる）
      const LEADER_LABELS = [
        "高市早苗（自民）",
        "吉村洋文（維新）",
        "野田佳彦（中道改革）",
        "玉木雄一郎（国民）",
        "田村智子（共産）",
        "山本太郎（れいわ）",
        "神谷宗幣（参政）",
        "百田尚樹（保守）",
        "福島瑞穂（社民）",
        "安野貴博（みらい）"
      ];
  
      /* ==========================================================
         1) Constants / Theme
         ========================================================== */
      const THEME = {
        colors: {
          grid: 0xcccccc,
          axisX: 0xff0000,
          axisY: 0x00aa00,
          axisZ: 0x0000ff,
          text: "#333333"
        },
        opacity: {
          point: 0.85,
          label: 0.9,
          dimmed: 0.15
        },
        duration: {
          hover: 0.3,
          camera: 1.5,
          filter: 0.5,
          resetScale: 0.2,
          coordinate: 0.8
        }
      };
  
      const BASE_URL = "https://www.yomiuri.co.jp/election/shugiin/2026/";
      const UI_SELECTORS = "#about-modal, #legend, #search-container, #about-btn, #search-results, #tooltip, #coord-selector";
  
      /* ==========================================================
         2) Shape texture helpers (キャッシュして無駄生成を抑える)
         - Legend icon: dataURL cache
         - Sprite: texture & material cache
         ========================================================== */
      const shapeTextureCache = new Map();   // key: "shape|#RRGGBB" -> THREE.CanvasTexture
      const shapeDataUrlCache = new Map();   // key: "shape|#RRGGBB" -> dataURL
      const spriteMaterialCache = new Map(); // key: "shape|#RRGGBB" -> THREE.SpriteMaterial（共有）
  
      function drawShapeToCanvas(type, color) {
        const size = 64;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
  
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = color;
  
        const center = size / 2;
        const radius = size / 2 - 4;
        const pad = 6;
  
        ctx.beginPath();
        if (type === 0) {
          ctx.arc(center, center, radius, 0, Math.PI * 2);
        } else if (type === 1) {
          ctx.rect(pad, pad, size - pad * 2, size - pad * 2);
        } else if (type === 2) {
          ctx.moveTo(center, pad);
          ctx.lineTo(size - pad, size - pad);
          ctx.lineTo(pad, size - pad);
          ctx.closePath();
        } else if (type === 3) {
          ctx.moveTo(center, pad);
          ctx.lineTo(size - pad, center);
          ctx.lineTo(center, size - pad);
          ctx.lineTo(pad, center);
          ctx.closePath();
        } else if (type === 4) {
          const w = 2 * pad;
          ctx.moveTo(center - w, pad); ctx.lineTo(center + w, pad);
          ctx.lineTo(center + w, center - w); ctx.lineTo(size - pad, center - w);
          ctx.lineTo(size - pad, center + w); ctx.lineTo(center + w, center + w);
          ctx.lineTo(center + w, size - pad); ctx.lineTo(center - w, size - pad);
          ctx.lineTo(center - w, center + w); ctx.lineTo(pad, center + w);
          ctx.lineTo(pad, center - w); ctx.lineTo(center - w, center - w);
          ctx.closePath();
        } else {
          ctx.arc(center, center, radius, 0, Math.PI * 2);
        }
        ctx.fill();
  
        return canvas;
      }
  
      function getShapeTexture(type, color) {
        const key = `${type}|${color}`;
        if (!shapeTextureCache.has(key)) {
          const canvas = drawShapeToCanvas(type, color);
          shapeTextureCache.set(key, new THREE.CanvasTexture(canvas));
        }
        return shapeTextureCache.get(key);
      }
  
      function getShapeDataUrl(type, color) {
        const key = `${type}|${color}`;
        if (!shapeDataUrlCache.has(key)) {
          const tex = getShapeTexture(type, color);
          shapeDataUrlCache.set(key, tex.image.toDataURL());
        }
        return shapeDataUrlCache.get(key);
      }
  
      function getSpriteMaterial(type, color) {
        const key = `${type}|${color}`;
        if (!spriteMaterialCache.has(key)) {
          spriteMaterialCache.set(key, new THREE.SpriteMaterial({
            map: getShapeTexture(type, color),
            transparent: true,
            opacity: THEME.opacity.point
          }));
        }
        return spriteMaterialCache.get(key);
      }
  
      function createTextTexture(text) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
  
        const fontSize = 64;
        ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
        const metrics = ctx.measureText(text);
  
        canvas.width = metrics.width + 20;
        canvas.height = fontSize + 20;
  
        // resizeでctxがリセットされるので再設定
        ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
        ctx.textBaseline = "middle";
        ctx.fillStyle = THEME.colors.text;
        ctx.fillText(text, 10, canvas.height / 2);
  
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        return { texture, width: canvas.width, height: canvas.height };
      }
  
      /* ==========================================================
         3) Three.js setup
         ========================================================== */
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
  
      const gridHelper = new THREE.GridHelper(100, 20, THEME.colors.grid, THEME.colors.grid);
      gridHelper.rotation.x = Math.PI / 2;
  
      // gridのチラつき(Z-fighting)軽減
      gridHelper.material.depthWrite = false;
      gridHelper.material.polygonOffset = true;
      gridHelper.material.polygonOffsetFactor = 10;
      gridHelper.material.polygonOffsetUnits = 10;
      scene.add(gridHelper);
  
      function toNumericPoint(value, fallback) {
        const num = Number(value);
        if (Number.isFinite(num)) return num;
        const fallbackNum = Number(fallback);
        if (Number.isFinite(fallbackNum)) return fallbackNum;
        return 0;
      }

      function getPointCoordinates(point, coordKey) {
        const set = COORDINATE_SETS[coordKey] || COORDINATE_SETS.pc;
        const raw = {
          x: toNumericPoint(point[set.x], point.x),
          y: toNumericPoint(point[set.y], point.y),
          z: toNumericPoint(point[set.z], point.z)
        };

        if (coordKey === "pc") {
          return {
            x: raw.x * 1.1,
            y: raw.y * 1.1,
            z: raw.z * 1.1
          };
        }

        if (coordKey === "ic") {
          return {
            x: raw.x,
            y: -raw.y,
            z: raw.z
          };
        }

        return raw;
      }

      // axes
      const origin = new THREE.Vector3(0, 0, 0);
      const axisLength = 55;
      const axisGroup = new THREE.Group();
      scene.add(axisGroup);

      function applyAxisLabels(coordSetKey) {
        const set = COORDINATE_SETS[coordSetKey] || COORDINATE_SETS.pc;
        axisGroup.clear();

        const defs = [
          { dir: new THREE.Vector3(1, 0, 0), color: THEME.colors.axisX, label: set.labels?.[0] || "X" },
          { dir: new THREE.Vector3(0, 1, 0), color: THEME.colors.axisY, label: set.labels?.[1] || "Y" },
          { dir: new THREE.Vector3(0, 0, 1), color: THEME.colors.axisZ, label: set.labels?.[2] || "Z" }
        ];

        for (const def of defs) {
          axisGroup.add(new THREE.ArrowHelper(def.dir, origin, axisLength, def.color, 2, 1));

          const labelData = createTextTexture(def.label);
          const labelSprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ map: labelData.texture, transparent: true, opacity: 0.8 })
          );
          labelSprite.position.copy(def.dir.clone().multiplyScalar(axisLength + 3));
          labelSprite.scale.set(labelData.width * 0.03, labelData.height * 0.03, 1);
          axisGroup.add(labelSprite);
        }
      }

      applyAxisLabels(activeCoordKey);
  
      // camera / renderer / controls
      const initialCameraPos = { x: 0, y: 0, z: 80 };
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);
  
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);
  
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.mouseButtons.LEFT = -1;
      controls.touches.ONE = -1;

      // マウス左ドラッグ/1本指ドラッグの独自回転
      let isPrimaryDragRotating = false;
      let primaryDragPointerId = null;
      let lastPrimaryX = 0;
      let lastPrimaryY = 0;
      const activeTouchPointerIds = new Set();

      function stopPrimaryDragRotate() {
        if (!isPrimaryDragRotating) return;
        const pointerId = primaryDragPointerId;
        isPrimaryDragRotating = false;
        primaryDragPointerId = null;
        if (pointerId !== null && renderer.domElement.hasPointerCapture(pointerId)) {
          renderer.domElement.releasePointerCapture(pointerId);
        }
      }

      function startPrimaryDragRotate(event) {
        const isMousePrimary = event.pointerType === "mouse" && event.button === 0;
        const isTouch = event.pointerType === "touch";
        if (!isMousePrimary && !isTouch) return;

        if (isTouch) {
          activeTouchPointerIds.add(event.pointerId);
          if (activeTouchPointerIds.size > 1) {
            stopPrimaryDragRotate();
            return;
          }
        }

        isPrimaryDragRotating = true;
        primaryDragPointerId = event.pointerId;
        lastPrimaryX = event.clientX;
        lastPrimaryY = event.clientY;
        mouseDownPos = { x: event.clientX, y: event.clientY };

        renderer.domElement.setPointerCapture(event.pointerId);
        event.preventDefault();
        event.stopPropagation();
      }

      function movePrimaryDragRotate(event) {
        if (!isPrimaryDragRotating) return;
        if (event.pointerId !== primaryDragPointerId) return;
        if (event.pointerType === "touch" && activeTouchPointerIds.size !== 1) return;

        const dx = event.clientX - lastPrimaryX;
        const dy = event.clientY - lastPrimaryY;
        lastPrimaryX = event.clientX;
        lastPrimaryY = event.clientY;

        const verticalRotateSpeed = (2 * Math.PI) / Math.max(renderer.domElement.clientHeight, 1);
        const rollRotateSpeed = (2 * Math.PI) / Math.max(renderer.domElement.clientWidth, 1);

        const screenHorizontalAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
        const pitchQuat = new THREE.Quaternion().setFromAxisAngle(screenHorizontalAxis, -dy * verticalRotateSpeed);
        const offset = camera.position.clone().sub(controls.target).applyQuaternion(pitchQuat);
        camera.position.copy(controls.target).add(offset);
        camera.up.applyQuaternion(pitchQuat);

        const worldZAxis = new THREE.Vector3(0, 0, 1);
        const yawQuat = new THREE.Quaternion().setFromAxisAngle(worldZAxis, -dx * rollRotateSpeed);
        const yawOffset = camera.position.clone().sub(controls.target).applyQuaternion(yawQuat);
        camera.position.copy(controls.target).add(yawOffset);
        camera.up.applyQuaternion(yawQuat);

        controls.update();
        event.preventDefault();
        event.stopPropagation();
      }

      function endPrimaryDragRotate(event) {
        if (event.pointerType === "touch") {
          activeTouchPointerIds.delete(event.pointerId);
        }
        if (event.pointerId === primaryDragPointerId) {
          stopPrimaryDragRotate();
        }
      }

      renderer.domElement.addEventListener("pointerdown", startPrimaryDragRotate, true);
      window.addEventListener("pointermove", movePrimaryDragRotate, true);
      window.addEventListener("pointerup", endPrimaryDragRotate, true);
      window.addEventListener("pointercancel", endPrimaryDragRotate, true);

      /* ==========================================================
         4) Candidates build
         ========================================================== */
      const candidateObjects = [];
      const targetSprites = [];
  
      function buildTooltipHtml(pt) {
        const rows = LEADER_LABELS.map((label, i) => {
          const v = pt.answer?.[i];
          return `<div class="tooltip-row"><span>${label}:</span><span class="tooltip-val">${v ?? "-"}</span></div>`;
        }).join("");
  
        return `
          <strong>${pt.name}</strong>
          <div class="tooltip-party">${pt.party}</div>
          ${rows}
        `;
      }
  
      for (const pt of pointsData) {
        const pos = getPointCoordinates(pt, activeCoordKey);
        // 点（スプライト）: 同じshape/colorは同じmaterialを共有
        const sprite = new THREE.Sprite(getSpriteMaterial(pt.shape, pt.color));
        sprite.position.set(pos.x, pos.y, pos.z);
  
        // ラベル（候補者名）: 個別テクスチャ（メモリを消費する点に注意）
        const textData = createTextTexture(pt.name);
        const label = new THREE.Sprite(new THREE.SpriteMaterial({
          map: textData.texture,
          transparent: true,
          opacity: THEME.opacity.label,
          depthTest: false
        }));
        label.position.set(pos.x, pos.y + LABEL_Y_OFFSET, pos.z);
        label.scale.set(textData.width * 0.012, textData.height * 0.012, 1);
        label.renderOrder = 999;
  
        sprite.userData = {
          url: pt.url,
          html: buildTooltipHtml(pt)
        };
  
        scene.add(sprite);
        scene.add(label);
  
        candidateObjects.push({
          name: pt.name,
          party: pt.party,
          sourceData: pt,
          sprite,
          label,
          position: new THREE.Vector3(pos.x, pos.y, pos.z)
        });

        targetSprites.push(sprite);
      }
  
      /* ==========================================================
         5) UI references
         ========================================================== */
      const legendDiv = document.getElementById("legend");
      const tooltip = document.getElementById("tooltip");
      const modal = document.getElementById("about-modal");
      const coordSelect = document.getElementById("coord-select");
  
      const searchInput = document.getElementById("search-input");
      const searchResults = document.getElementById("search-results");
  
      /* ==========================================================
         6) Party filter (legend)
         - sprite materialは共有されるので、同一materialへのgsap多重発行を避ける
         ========================================================== */
      let activeParty = null;
  
      function tweenOpacity(material, targetOpacity) {
        // 変化がほぼ無い場合はGSAP発行を抑制
        if (Math.abs(material.opacity - targetOpacity) < 0.001) return;
        gsap.to(material, {
          opacity: targetOpacity,
          duration: THEME.duration.filter,
          ease: "power2.out"
        });
      }
  
      function applyPartyFilter() {
        // spriteは共有materialがあるのでdedupe（material単位で1回だけ）
        const spriteTargets = new Map(); // material -> targetOpacity
  
        for (const obj of candidateObjects) {
          const isMatch = !activeParty || obj.party === activeParty;
  
          // labelは個別materialなのでそのまま
          tweenOpacity(obj.label.material, isMatch ? THEME.opacity.label : THEME.opacity.dimmed);
  
          // sprite materialは共有される場合がある
          const m = obj.sprite.material;
          spriteTargets.set(m, isMatch ? THEME.opacity.point : THEME.opacity.dimmed);
        }
  
        for (const [m, op] of spriteTargets) {
          tweenOpacity(m, op);
        }
      }
  
      function renderLegend() {
        const frag = document.createDocumentFragment();
        const legendEls = []; // selected切替をquerySelectorAllなしで行う
  
        for (const item of legendData) {
          const div = document.createElement("div");
          div.className = "legend-item";
  
          const iconUrl = getShapeDataUrl(item.style.shape, item.style.color);
          div.innerHTML = `<img src="${iconUrl}" class="legend-icon" alt=""><span>${item.party}</span>`;
  
          div.addEventListener("click", () => {
            const same = activeParty === item.party;
            activeParty = same ? null : item.party;
  
            for (const el of legendEls) el.classList.remove("selected");
            if (!same) div.classList.add("selected");
  
            applyPartyFilter();
          });
  
          legendEls.push(div);
          frag.appendChild(div);
        }
  
        legendDiv.appendChild(frag);
      }
      renderLegend();

      function applyCoordinateSet(coordKey) {
        const key = COORDINATE_SETS[coordKey] ? coordKey : "pc";
        activeCoordKey = key;

        for (const obj of candidateObjects) {
          const pos = getPointCoordinates(obj.sourceData, key);
          gsap.killTweensOf([obj.position, obj.sprite.position, obj.label.position]);

          gsap.to(obj.position, {
            x: pos.x,
            y: pos.y,
            z: pos.z,
            duration: THEME.duration.coordinate,
            ease: "power2.inOut"
          });

          gsap.to(obj.sprite.position, {
            x: pos.x,
            y: pos.y,
            z: pos.z,
            duration: THEME.duration.coordinate,
            ease: "power2.inOut"
          });

          gsap.to(obj.label.position, {
            x: pos.x,
            y: pos.y + LABEL_Y_OFFSET,
            z: pos.z,
            duration: THEME.duration.coordinate,
            ease: "power2.inOut"
          });
        }

        applyAxisLabels(key);
      }

      coordSelect.value = activeCoordKey;
      coordSelect.addEventListener("change", (e) => {
        applyCoordinateSet(e.target.value);
        hideTooltip();
        resetScale();
      });
  
      /* ==========================================================
         7) Tooltip + pointer interactions
         ========================================================== */
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
  
      let hoveredSprite = null;
      let currentData = null;
      let mouseDownPos = { x: 0, y: 0 };
  
      function updateTooltipPos(clientX, clientY) {
        // 右端にはみ出しやすいので固定幅で簡易回避（改善推薦は末尾）
        const tooltipW = 220;
        const xPos = (clientX + tooltipW > window.innerWidth) ? clientX - tooltipW : clientX + 15;
        tooltip.style.left = `${xPos}px`;
        tooltip.style.top = `${clientY - 40}px`;
      }
  
      function showTooltip(data) {
        tooltip.innerHTML = data.html;
        tooltip.style.display = "block";
      }
  
      function hideTooltip() {
        tooltip.style.display = "none";
        document.body.style.cursor = "default";
      }
  
      function jumpToUrl(data) {
        if (data?.url) {
          window.open(BASE_URL + data.url, "_blank", "noopener");
        }
      }
  
      function pickSprite(clientX, clientY) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
  
        const intersects = raycaster.intersectObjects(targetSprites, false);
        return intersects.length ? intersects[0].object : null;
      }
  
      function resetScale() {
        if (!hoveredSprite) return;
        gsap.to(hoveredSprite.scale, { x: 1, y: 1, duration: THEME.duration.resetScale });
        hoveredSprite = null;
      }
  
      window.addEventListener("pointerdown", (e) => {
        if (e.target.closest(UI_SELECTORS)) return;
        mouseDownPos = { x: e.clientX, y: e.clientY };
      });
  
      // PC hover（touchはhoverしない）
      window.addEventListener("pointermove", (e) => {
        if (e.pointerType === "touch") return;
  
        if (e.target.closest(UI_SELECTORS) || e.buttons > 0) {
          hideTooltip();
          return;
        }
  
        const hit = pickSprite(e.clientX, e.clientY);
        if (!hit) {
          hideTooltip();
          resetScale();
          return;
        }
  
        if (hoveredSprite !== hit) {
          resetScale();
          hoveredSprite = hit;
          gsap.to(hit.scale, { x: 1.5, y: 1.5, duration: THEME.duration.hover, ease: "power3.out" });
        }
  
        currentData = hit.userData;
        showTooltip(currentData);
        updateTooltipPos(e.clientX, e.clientY);
        document.body.style.cursor = "pointer";
      });
  
      // PC click = open / touch tap = show tooltip
      window.addEventListener("pointerup", (e) => {
        if (e.target.closest(UI_SELECTORS)) return;
  
        const dist = Math.hypot(e.clientX - mouseDownPos.x, e.clientY - mouseDownPos.y);
        if (dist > 5) return;
  
        const hit = pickSprite(e.clientX, e.clientY);
        if (!hit) {
          if (e.pointerType === "touch") {
            hideTooltip();
            resetScale();
          }
          return;
        }
  
        const data = hit.userData;
  
        if (e.pointerType === "touch") {
          if (hoveredSprite !== hit) {
            resetScale();
            hoveredSprite = hit;
            gsap.to(hit.scale, { x: 1.5, y: 1.5, duration: THEME.duration.hover });
          }
          currentData = data;
          showTooltip(data);
          updateTooltipPos(e.clientX, e.clientY);
        } else {
          jumpToUrl(data);
        }
      });
  
      // tooltip tap => open detail（モバイル向け）
      tooltip.addEventListener("pointerup", (e) => {
        e.stopPropagation();
        if (currentData) jumpToUrl(currentData);
      });
  
      /* ==========================================================
         8) Render loop
         ========================================================== */
      function animate() {
        requestAnimationFrame(animate);
  
        const time = performance.now() * 0.005;
        const pulseScale = 1.4 + Math.sin(time) * 0.4;
  
        for (const obj of candidateObjects) {
          if (obj.sprite === hoveredSprite) continue;
          const targetScale = (activeParty && obj.party === activeParty) ? pulseScale : 1;
          if (Math.abs(obj.sprite.scale.x - targetScale) > 0.01) {
            obj.sprite.scale.set(targetScale, targetScale, 1);
          }
        }
  
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
  
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
  
      /* ==========================================================
         9) About modal
         ========================================================== */
      document.getElementById("about-btn").addEventListener("click", () => {
        modal.style.display = "flex";
      });
  
      document.getElementById("close-modal").addEventListener("click", () => {
        modal.style.display = "none";
      });
  
      window.addEventListener("click", (e) => {
        if (e.target === modal) modal.style.display = "none";
      });
  
      /* ==========================================================
         10) Search
         ========================================================== */
      searchInput.addEventListener("input", (e) => {
        const val = e.target.value.trim();
        searchResults.innerHTML = "";
  
        if (!val) {
          searchResults.style.display = "none";
          return;
        }
  
        const matches = candidateObjects.filter(obj => obj.name.includes(val) || obj.party.includes(val));
        if (matches.length === 0) {
          searchResults.style.display = "none";
          return;
        }
  
        const frag = document.createDocumentFragment();
        for (const match of matches) {
          const li = document.createElement("li");
          li.className = "search-item";
          li.innerHTML = `<span>${match.name}</span><span class="search-party">${match.party}</span>`;
  
          li.addEventListener("click", () => {
            focusCandidate(match);
            searchResults.style.display = "none";
            searchInput.value = match.name;
          });
  
          frag.appendChild(li);
        }
  
        searchResults.appendChild(frag);
        searchResults.style.display = "block";
      });
  
      // Enter: first item or reset view
      searchInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
  
        const val = searchInput.value.trim();
        if (!val) {
          resetView();
          searchInput.blur();
          return;
        }
  
        const first = searchResults.querySelector(".search-item");
        if (first) {
          first.click();
          searchInput.blur();
        }
      });
  
      function focusCandidate(candidateObj) {
        const targetPos = candidateObj.position;
  
        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z + 15,
          duration: THEME.duration.camera,
          ease: "power3.inOut",
          onUpdate: () => controls.update()
        });
  
        gsap.to(controls.target, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: THEME.duration.camera,
          ease: "power3.inOut"
        });
      }
  
      function resetView() {
        gsap.to(camera.position, {
          x: initialCameraPos.x,
          y: initialCameraPos.y,
          z: initialCameraPos.z,
          duration: THEME.duration.camera,
          ease: "power3.inOut",
          onUpdate: () => controls.update()
        });
  
        gsap.to(controls.target, {
          x: 0, y: 0, z: 0,
          duration: THEME.duration.camera,
          ease: "power3.inOut"
        });
      }
    }

    main();
  </script>
</body>
</html>
